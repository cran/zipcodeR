<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Basic search functions</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<p><code>zipcodeR</code> is an all-in-one toolkit of functions and data for working with ZIP codes in R.</p>

<p>This document will introduce the tools provided by zipcodeR for improving your workflow when working with ZIP code-level data. The goal of these examples is to help you quickly get up and running with zipcodeR using real-world examples.</p>

<h2>Basic search functions</h2>

<p>First thing&#39;s first: <code>zipcodeR</code>&#39;s data &amp; basic search functions are a core component of the package. We&#39;ll cover these before showing you how you can implement this package with a real-world example.</p>

<h2>Data</h2>

<p>The package ships with an offline database containing 24 columns of data for each ZIP code. You can either keep all 24 variables or filter to just one of these depending on what data you need.</p>

<p>The columns of data provided are:
<strong>zipcode, zipcode_type, major_city, post_office_city, common_city_list, county, state, lat, lng, timezone, radius_in_miles, area_code_list, population, population_density, land_area_in_sqmi, water_area_in_sqmi, housing_units, occupied_housing_units, median_home_value, median_household_income, bounds_west, bounds_east, bounds_north, bounds_south</strong></p>

<h2>Searching for ZIP codes by state</h2>

<p>Let&#39;s begin by using zipcodeR to find all ZIP codes within a given state.</p>

<p>Getting all ZIP codes for a single state is simple, you only need to pass a two-digit abbreviation of a state&#39;s name to get a tibble of all ZIP codes in that state. Let&#39;s start by finding all of the ZIP codes in New York:</p>

<pre><code class="r">search_state(&#39;NY&#39;)
</code></pre>

<pre><code>## 2208 ZIP codes found for state: &quot;NY&quot;
</code></pre>

<pre><code>## # A tibble: 2,208 x 24
##    zipcode zipcode_type major_city post_office_city common_city_list county
##    &lt;chr&gt;   &lt;chr&gt;        &lt;chr&gt;      &lt;chr&gt;                 &lt;list&lt;raw&gt;&gt; &lt;chr&gt; 
##  1 00501   Unique       Holtsville &lt;NA&gt;                         [22] Suffo~
##  2 00544   Unique       Holtsville &lt;NA&gt;                         [22] Suffo~
##  3 06390   PO Box       Fishers I~ Fishers Island,~             [32] Suffo~
##  4 10001   Standard     New York   New York, NY                 [20] New Y~
##  5 10002   Standard     New York   New York, NY                 [34] New Y~
##  6 10003   Standard     New York   New York, NY                 [20] New Y~
##  7 10004   Standard     New York   New York, NY                 [37] New Y~
##  8 10005   Standard     New York   New York, NY                 [35] New Y~
##  9 10006   Standard     New York   New York, NY                 [31] New Y~
## 10 10007   Standard     New York   New York, NY                 [20] New Y~
## # ... with 2,198 more rows, and 18 more variables: state &lt;chr&gt;, lat &lt;dbl&gt;,
## #   lng &lt;dbl&gt;, timezone &lt;chr&gt;, radius_in_miles &lt;dbl&gt;,
## #   area_code_list &lt;list&lt;raw&gt;&gt;, population &lt;int&gt;, population_density &lt;dbl&gt;,
## #   land_area_in_sqmi &lt;dbl&gt;, water_area_in_sqmi &lt;dbl&gt;, housing_units &lt;int&gt;,
## #   occupied_housing_units &lt;int&gt;, median_home_value &lt;int&gt;,
## #   median_household_income &lt;int&gt;, bounds_west &lt;dbl&gt;, bounds_east &lt;dbl&gt;,
## #   bounds_north &lt;dbl&gt;, bounds_south &lt;dbl&gt;
</code></pre>

<p>What if you only wanted the actual ZIP codes and no other variables? You can use R&#39;s dollar sign operator to select one column at a time from the output of <code>zipcodeR</code>&#39;s search functions:</p>

<pre><code class="r">nyzip &lt;- search_state(&#39;NY&#39;)$zipcode
</code></pre>

<pre><code>## 2208 ZIP codes found for state: &quot;NY&quot;
</code></pre>

<h3>Searching multiple states at once</h3>

<p>You can also search for ZIP codes in multiple states at once by passing a vector of state abbreviations to the search_states function like so:</p>

<pre><code class="r">states &lt;- c(&#39;NY&#39;,&#39;NJ&#39;,&#39;CT&#39;)

search_state(states)
</code></pre>

<pre><code>## 3378 ZIP codes found for states: &quot;NY&quot;, &quot;NJ&quot;, &quot;CT&quot;
</code></pre>

<pre><code>## # A tibble: 3,378 x 24
##    zipcode zipcode_type major_city post_office_city common_city_list county
##    &lt;chr&gt;   &lt;chr&gt;        &lt;chr&gt;      &lt;chr&gt;                 &lt;list&lt;raw&gt;&gt; &lt;chr&gt; 
##  1 06001   Standard     Avon       Avon, CT                     [16] Hartf~
##  2 06002   Standard     Bloomfield Bloomfield, CT               [22] Hartf~
##  3 06006   Unique       Windsor    &lt;NA&gt;                         [19] Hartf~
##  4 06010   Standard     Bristol    Bristol, CT                  [19] Hartf~
##  5 06011   PO Box       Bristol    &lt;NA&gt;                         [19] Hartf~
##  6 06013   Standard     Burlington Burlington, CT               [36] Hartf~
##  7 06016   Standard     Broad Bro~ Broad Brook, CT              [46] Hartf~
##  8 06018   Standard     Canaan     Canaan, CT                   [18] Litch~
##  9 06019   Standard     Canton     Canton, CT                   [34] Hartf~
## 10 06020   Standard     Canton Ce~ Canton Center, ~             [25] Hartf~
## # ... with 3,368 more rows, and 18 more variables: state &lt;chr&gt;, lat &lt;dbl&gt;,
## #   lng &lt;dbl&gt;, timezone &lt;chr&gt;, radius_in_miles &lt;dbl&gt;,
## #   area_code_list &lt;list&lt;raw&gt;&gt;, population &lt;int&gt;, population_density &lt;dbl&gt;,
## #   land_area_in_sqmi &lt;dbl&gt;, water_area_in_sqmi &lt;dbl&gt;, housing_units &lt;int&gt;,
## #   occupied_housing_units &lt;int&gt;, median_home_value &lt;int&gt;,
## #   median_household_income &lt;int&gt;, bounds_west &lt;dbl&gt;, bounds_east &lt;dbl&gt;,
## #   bounds_north &lt;dbl&gt;, bounds_south &lt;dbl&gt;
</code></pre>

<p>This results in a tibble containing all ZIP codes for the states passed to the <code>search_states()</code> function.</p>

<h2>Searching by county</h2>

<p>It is also possible to search for ZIP codes located in a particular county within a state.</p>

<p>Let&#39;s find all of the ZIP codes located within Ocean County, New Jersey:</p>

<pre><code class="r">search_county(&#39;Ocean&#39;,&#39;NJ&#39;)
</code></pre>

<pre><code>## [1] &quot;32 ZIP codes found for Ocean County , NJ&quot;
</code></pre>

<pre><code>## # A tibble: 32 x 24
##    zipcode zipcode_type major_city post_office_city common_city_list county
##    &lt;chr&gt;   &lt;chr&gt;        &lt;chr&gt;      &lt;chr&gt;                 &lt;list&lt;raw&gt;&gt; &lt;chr&gt; 
##  1 08005   Standard     Barnegat   Barnegat, NJ                 [20] Ocean~
##  2 08006   PO Box       Barnegat ~ Barnegat Light,~             [33] Ocean~
##  3 08008   Standard     Beach Hav~ Beach Haven, NJ              [61] Ocean~
##  4 08050   Standard     Manahawkin Manahawkin, NJ               [47] Ocean~
##  5 08087   Standard     Tuckerton  Tuckerton, NJ                [51] Ocean~
##  6 08092   Standard     West Creek West Creek, NJ               [22] Ocean~
##  7 08527   Standard     Jackson    Jackson, NJ                  [19] Ocean~
##  8 08533   Standard     New Egypt  New Egypt, NJ                [21] Ocean~
##  9 08701   Standard     Lakewood   Lakewood, NJ                 [20] Ocean~
## 10 08721   Standard     Bayville   Bayville, NJ                 [20] Ocean~
## # ... with 22 more rows, and 18 more variables: state &lt;chr&gt;, lat &lt;dbl&gt;,
## #   lng &lt;dbl&gt;, timezone &lt;chr&gt;, radius_in_miles &lt;dbl&gt;,
## #   area_code_list &lt;list&lt;raw&gt;&gt;, population &lt;int&gt;, population_density &lt;dbl&gt;,
## #   land_area_in_sqmi &lt;dbl&gt;, water_area_in_sqmi &lt;dbl&gt;, housing_units &lt;int&gt;,
## #   occupied_housing_units &lt;int&gt;, median_home_value &lt;int&gt;,
## #   median_household_income &lt;int&gt;, bounds_west &lt;dbl&gt;, bounds_east &lt;dbl&gt;,
## #   bounds_north &lt;dbl&gt;, bounds_south &lt;dbl&gt;
</code></pre>

<h3>Approximate matching of county names</h3>

<p>Sometimes working with county names can be messy and there might not be a 100% match between our database and the name. The <code>search_county()</code> function can be configured to use base R&#39;s <code>agrep</code> function for these cases via an optional parameter.</p>

<p>One example where this feature is useful comes from the state of Louisiana. Since Louisiana has parishes, their county names don&#39;t line up exactly with how other states name their counties.</p>

<p>This example uses approxmiate matching to retrieve all ZIP codes for St. Bernard Parish in Louisiana:</p>

<pre><code class="r">search_county(&quot;ST BERNARD&quot;,&quot;LA&quot;, similar = TRUE)$zipcode
</code></pre>

<pre><code>## [1] &quot;6 ZIP codes found for St. Bernard Parish , LA or St Bernard Parish , LA&quot;
</code></pre>

<pre><code>## [1] &quot;70032&quot; &quot;70043&quot; &quot;70044&quot; &quot;70075&quot; &quot;70085&quot; &quot;70092&quot;
</code></pre>

<p>Try running the above code with the similar parameter set to FALSE or not present and you&#39;ll receive an error.</p>

<h2>Finding out more about your ZIP codes</h2>

<p>What if you already have a dataset containing ZIP codes and want to find out more about that particular area?</p>

<p>Using the reverse_zipcode() function, we can get up to 24 more columns of data when given a ZIP code.</p>

<h2>Data: U.S. Real Estate Market</h2>

<p>To explore how zipcodeR can enhance your data &amp; workflow, we will use a public dataset from the <a href="https://www.realtor.com/research/data/">National Association of Realtors</a> containing data about housing market trends in the United States.</p>

<p>This dataset, which is updated monthly, contains 11102 observations with current housing market data from the National Association of Realtors <a href="https://econdata.s3-us-west-2.amazonaws.com/Reports/Core/RDC_Inventory_Core_Metrics_Zip.csv">hosted on Amazon S3</a></p>

<p>This is what the data we will be working with looks like:</p>

<pre><code class="r">head(real_estate_data)
</code></pre>

<pre><code>## # A tibble: 6 x 40
##   month_date_yyyy~ postal_code zip_name flag  median_listing_~ median_listing_~
##              &lt;dbl&gt; &lt;chr&gt;       &lt;chr&gt;    &lt;chr&gt;            &lt;dbl&gt;            &lt;dbl&gt;
## 1           202011 11766       mount s~ *              584550.            0.063
## 2           202011 16316       conneau~ *              239950             0.372
## 3           202011 96064       montagu~ &lt;NA&gt;           417050            -0.240
## 4           202011 30176       tallapo~ *              349950             0.211
## 5           202011 11798       wyandan~ &lt;NA&gt;           402050             0.072
## 6           202011 75709       tyler, ~ *              363050            -0.081
## # ... with 34 more variables: median_listing_price_yy &lt;dbl&gt;,
## #   active_listing_count &lt;dbl&gt;, active_listing_count_mm &lt;dbl&gt;,
## #   active_listing_count_yy &lt;dbl&gt;, median_days_on_market &lt;dbl&gt;,
## #   median_days_on_market_mm &lt;dbl&gt;, median_days_on_market_yy &lt;dbl&gt;,
## #   new_listing_count &lt;dbl&gt;, new_listing_count_mm &lt;dbl&gt;,
## #   new_listing_count_yy &lt;dbl&gt;, price_increased_count &lt;dbl&gt;,
## #   price_increased_count_mm &lt;dbl&gt;, price_increased_count_yy &lt;dbl&gt;,
## #   price_reduced_count &lt;dbl&gt;, price_reduced_count_mm &lt;dbl&gt;,
## #   price_reduced_count_yy &lt;dbl&gt;, pending_listing_count &lt;dbl&gt;,
## #   pending_listing_count_mm &lt;dbl&gt;, pending_listing_count_yy &lt;dbl&gt;,
## #   median_listing_price_per_square_foot &lt;dbl&gt;,
## #   median_listing_price_per_square_foot_mm &lt;dbl&gt;,
## #   median_listing_price_per_square_foot_yy &lt;dbl&gt;, median_square_feet &lt;dbl&gt;,
## #   median_square_feet_mm &lt;dbl&gt;, median_square_feet_yy &lt;dbl&gt;,
## #   average_listing_price &lt;dbl&gt;, average_listing_price_mm &lt;dbl&gt;,
## #   average_listing_price_yy &lt;dbl&gt;, total_listing_count &lt;dbl&gt;,
## #   total_listing_count_mm &lt;dbl&gt;, total_listing_count_yy &lt;dbl&gt;,
## #   pending_ratio &lt;dbl&gt;, pending_ratio_mm &lt;dbl&gt;, pending_ratio_yy &lt;dbl&gt;
</code></pre>

<p>Note: The data used in this vignette was filtered to only include valid 5-digit ZIP codes as zipcodeR does not yet have a function for normalizing ZIP codes. The full Realtor dataset will have a different number of rows.</p>

<p>We&#39;ll focus on the first row for now, which represents the town of
Mount Sinai, Ny.</p>

<pre><code class="r">real_estate_data[1,]
</code></pre>

<pre><code>## # A tibble: 1 x 40
##   month_date_yyyy~ postal_code zip_name flag  median_listing_~ median_listing_~
##              &lt;dbl&gt; &lt;chr&gt;       &lt;chr&gt;    &lt;chr&gt;            &lt;dbl&gt;            &lt;dbl&gt;
## 1           202011 11766       mount s~ *              584550.            0.063
## # ... with 34 more variables: median_listing_price_yy &lt;dbl&gt;,
## #   active_listing_count &lt;dbl&gt;, active_listing_count_mm &lt;dbl&gt;,
## #   active_listing_count_yy &lt;dbl&gt;, median_days_on_market &lt;dbl&gt;,
## #   median_days_on_market_mm &lt;dbl&gt;, median_days_on_market_yy &lt;dbl&gt;,
## #   new_listing_count &lt;dbl&gt;, new_listing_count_mm &lt;dbl&gt;,
## #   new_listing_count_yy &lt;dbl&gt;, price_increased_count &lt;dbl&gt;,
## #   price_increased_count_mm &lt;dbl&gt;, price_increased_count_yy &lt;dbl&gt;,
## #   price_reduced_count &lt;dbl&gt;, price_reduced_count_mm &lt;dbl&gt;,
## #   price_reduced_count_yy &lt;dbl&gt;, pending_listing_count &lt;dbl&gt;,
## #   pending_listing_count_mm &lt;dbl&gt;, pending_listing_count_yy &lt;dbl&gt;,
## #   median_listing_price_per_square_foot &lt;dbl&gt;,
## #   median_listing_price_per_square_foot_mm &lt;dbl&gt;,
## #   median_listing_price_per_square_foot_yy &lt;dbl&gt;, median_square_feet &lt;dbl&gt;,
## #   median_square_feet_mm &lt;dbl&gt;, median_square_feet_yy &lt;dbl&gt;,
## #   average_listing_price &lt;dbl&gt;, average_listing_price_mm &lt;dbl&gt;,
## #   average_listing_price_yy &lt;dbl&gt;, total_listing_count &lt;dbl&gt;,
## #   total_listing_count_mm &lt;dbl&gt;, total_listing_count_yy &lt;dbl&gt;,
## #   pending_ratio &lt;dbl&gt;, pending_ratio_mm &lt;dbl&gt;, pending_ratio_yy &lt;dbl&gt;
</code></pre>

<p>The Realtor dataset contains a column named <strong>postal_code</strong> containing the ZIP code that identifies the town. We&#39;ll use this to find out more about Mount Sinai than what is provided in the housing market data.</p>

<h2>Reverse ZIP code search</h2>

<p>So far we&#39;ve covered the functions provided by <code>zipcodeR</code> for searching ZIP codes across multiple geographies. The package also provides a function for going in reverse, when given a 5-digit ZIP code. Introducing <code>reverse_zipcode()</code>:</p>

<pre><code class="r"># Get the ZIP code of the first row of data
zip_code &lt;- real_estate_data[1,]$postal_code

# Pass the ZIP code to the reverse_zipcode() function

reverse_zipcode(zip_code)
</code></pre>

<pre><code>## 1 row of data found for ZIP code: &quot;11766&quot;
</code></pre>

<pre><code>## # A tibble: 1 x 24
##   zipcode zipcode_type major_city post_office_city common_city_list county state
##   &lt;chr&gt;   &lt;chr&gt;        &lt;chr&gt;      &lt;chr&gt;                 &lt;list&lt;raw&gt;&gt; &lt;chr&gt;  &lt;chr&gt;
## 1 11766   Standard     Mount Sin~ Mount Sinai, NY              [23] Suffo~ NY   
## # ... with 17 more variables: lat &lt;dbl&gt;, lng &lt;dbl&gt;, timezone &lt;chr&gt;,
## #   radius_in_miles &lt;dbl&gt;, area_code_list &lt;list&lt;raw&gt;&gt;, population &lt;int&gt;,
## #   population_density &lt;dbl&gt;, land_area_in_sqmi &lt;dbl&gt;,
## #   water_area_in_sqmi &lt;dbl&gt;, housing_units &lt;int&gt;,
## #   occupied_housing_units &lt;int&gt;, median_home_value &lt;int&gt;,
## #   median_household_income &lt;int&gt;, bounds_west &lt;dbl&gt;, bounds_east &lt;dbl&gt;,
## #   bounds_north &lt;dbl&gt;, bounds_south &lt;dbl&gt;
</code></pre>

<h2>Relating ZIP codes to Census data</h2>

<p>You may also be interested in relating data at the ZIP code level to Census data. <code>zipcodeR</code> currently provides a function for getting all Census tracts when provided with a 5-digit ZIP code.</p>

<p>Let&#39;s find out how many Census tracts are in the ZIP code from the previous example.</p>

<pre><code class="r">get_tracts(zip_code)
</code></pre>

<pre><code>## 9 Census tracts found for ZIP code 11766
</code></pre>

<pre><code>## # A tibble: 9 x 3
##   ZCTA5 TRACT        GEOID
##   &lt;chr&gt; &lt;chr&gt;        &lt;dbl&gt;
## 1 11766 158202 36103158202
## 2 11766 158205 36103158205
## 3 11766 158304 36103158304
## 4 11766 158306 36103158306
## 5 11766 158308 36103158308
## 6 11766 158309 36103158309
## 7 11766 158320 36103158320
## 8 11766 158322 36103158322
## 9 11766 158323 36103158323
</code></pre>

<p>Now that you have all of the tracts for this ZIP code, it would be very easy to join this with other Census data, such as that which is available from the American Community Survey and other sources.</p>

<p>But ZIP codes alone are not terribly useful for social science research since they are only meant to represent USPS service areas. The Census Bureau has established <a href="https://www.census.gov/programs-surveys/geography/guidance/geo-areas/zctas.html">ZIP code tabulation areas (ZCTAs)</a> that provide a representation of ZIP codes and can be used for joining with Census data. But not every ZIP code is also a ZCTA.</p>

<h2>Testing if a ZIP code is a ZCTA</h2>

<p><code>zipcodeR</code> provides a function for testing if a given ZIP code is also a ZIP code tabulation area. When provided with a vector of 5-digit ZIP codes the function will return TRUE or FALSE based upon whether the ZIP code is also a ZCTA.</p>

<pre><code class="r">is_zcta(zip_code)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

</body>

</html>
